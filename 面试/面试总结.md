- 什么是IOC

  ```
  控制反转，又被称为依赖注入(DI)，是一种通过反射机制降低对象之间耦合关系的设计思想。Spring采用IOC的方式把实例化的对象注入到自定义的对象中。
  Demo实现：
  1、配置Spring Config的xml文件，定义<bean>（每个bean都有对应的类），属性<property>可初始化实例：
      <bean id="tea" class="spring.bean.Tea" scope="singleton">
          <property name="name" value="红茶"/>
          <property name="price" value="22.0"/>
      </bean>
  2、使用FileSystemXmlApplicationContext（绝对路径读取xml）
  或者ClassPathXmlApplicationContext（classpath相对路径读取xml），将实例化后的对象注入到spring容器中(scope默认是singleton，只会生成Tea的唯一bean，而scope=prototype时，可以生成过个bean，类似于new)。
  ```

  ![1576905056736](https://github.com/qxkmust/Alex.blog.github.io/blob/blog/Images/1576905056736.png?raw=true)

- 什么是AOP

  ```
  面向切面编程(AOP)是对面向对象开发(OOP)的一种补充，它允许在不改变原来模型的基础上动态的修改模型以满足新的需求（可以动态扩展），常用来动态增加日志、异常处理、鉴权。
  AOP常见的实现方式JDK静态代理、JDK动态代理、Cglib第三方代理
  ```

  - JDK静态代理

    原理是与目标类实现相同的接口，在代理类中切入增强逻辑。

    ```
    public class Jdk静态代理 implements Deal {
        private Deal target = new Consumer();
        @Override
        public void buy() {
            System.out.println("Before invoke buy()");
            target.buy();
            System.out.println("After invoke buy()");
        }
    }
    ```

    调用

    ```
    public void test01(){
    	Jdk静态代理 proxy = new Jdk静态代理();
    	proxy.buy();
    }
    ```

  - JDK动态代理

    实现InvocationHandler接口

    ```
    public class Jdk动态代理 implements InvocationHandler {
    //    代理对象
        private Object target;
    
        public Jdk动态代理(Object target) {
            this.target = target;
        }
    
        public Object getTargetProxy(){
            return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
        }
    
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("Before invoke "+method.getName());
            Object invoke = method.invoke(target, args);
            System.out.println("After invoke "+method.getName());
            return invoke;
        }
    }
    ```

    调用

    ```
     public void test02(){
            Consumer target = new Consumer();
            target.setProduct(new Tea("大红袍",99.0f));
            Jdk动态代理 jdk = new Jdk动态代理(target);
            Deal proxy = (Deal) jdk.getTargetProxy();
            proxy.buy();
        }
    ```

  - Cglib

    实现MethodInterceptor

    ```
    public class Cglib implements MethodInterceptor {
        /**
         * 重写方法拦截，在方法前和方法后增加业务
         * @param target 目标对象
         * @param method 目标方法
         * @param args 参数
         * @param methodProxy 方法代理对象
         * @return
         * @throws Throwable
         */
        @Override
        public Object intercept(Object target, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
            System.out.println("Before invoke "+method.getName());
            Object invokeSuper = methodProxy.invokeSuper(target, args);
            System.out.println("After invoke "+method.getName());
            return invokeSuper;
        }
    }
    ```

    调用-使用Enhancer字节码增强器

    ```
        public void test03(){
    //        通过字节码增强器对目标方法进行扩展
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(Product.class);
            enhancer.setCallback(new Cglib());
            Product proxy = (Product) enhancer.create();
            proxy.discount();
        }
    ```

    
